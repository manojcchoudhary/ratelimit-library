# Advanced Rate Limiting Configuration
# Complete example showing all available options

ratelimit:
  # Global enable/disable
  enabled: true
  
  # ========================================
  # PROXY CONFIGURATION (Hop Counting)
  # ========================================
  # Prevents IP spoofing in multi-layered environments
  proxy:
    # Number of trusted hops from right of X-Forwarded-For chain
    # 0 = use rightmost IP (most recent proxy)
    # 1 = skip 1 from right (typical: single reverse proxy)
    # 2 = skip 2 from right (typical: CDN + reverse proxy)
    trusted-hops: 1
    
    # CIDR ranges of trusted proxies
    # Only requests from these IPs will use hop counting
    # If empty, all proxies are trusted (less secure)
    trusted-proxies:
      - 10.0.0.0/8           # Private network
      - 172.16.0.0/12        # Kubernetes cluster network
      - 192.168.1.0/24       # Load balancer subnet
      # Add your CDN IP ranges here:
      # - 103.21.244.0/22    # Cloudflare example
      # - 103.22.200.0/22    # Cloudflare example
  
  # ========================================
  # ADAPTIVE THROTTLING
  # ========================================
  # Graceful degradation instead of hard blocking
  throttle:
    # Enable adaptive throttling
    enabled: true
    
    # Start throttling at X% of limit
    # Example: limit=100, soft=80 → throttling starts at 80 requests
    soft-limit-percentage: 80
    
    # Maximum delay to inject (milliseconds)
    # At hard limit, this is the maximum delay applied
    max-delay-ms: 2000
    
    # Delay calculation strategy
    # LINEAR: Proportional delay (predictable)
    # EXPONENTIAL: Minimal delay initially, aggressive near limit
    strategy: LINEAR
    
    # Use non-blocking delay (for reactive apps)
    # false = Thread.sleep (simpler, for MVC)
    # true = CompletableFuture (for WebFlux)
    non-blocking: false
  
  # ========================================
  # RFC 9457 PROBLEM DETAILS
  # ========================================
  # Standardized machine-readable error responses
  problem-details:
    # Enable RFC 9457 responses
    enabled: true
    
    # Include extension fields (limit, remaining, reset)
    include-extensions: true
    
    # Custom problem type URI
    type-uri: "https://ratelimit.io/probs/too-many-requests"
  
  # ========================================
  # SPEL CONFIGURATION
  # ========================================
  spel:
    # SpEL compiler mode for 40× performance boost
    # IMMEDIATE: Compile on first use (recommended)
    # MIXED: Compile after multiple uses
    # OFF: Never compile (slower)
    compiler-mode: IMMEDIATE
    
    # Expression cache size
    cache-size: 1000

# ========================================
# USAGE EXAMPLES
# ========================================

# Example 1: Per-User Rate Limit with Adaptive Throttling
# @RateLimit(
#   key = "#user.id",
#   requests = 100,
#   window = 60
# )
# Result:
# - At 80 requests: 0ms delay
# - At 90 requests: 1000ms delay (50% between soft and hard)
# - At 100 requests: 2000ms delay + block

# Example 2: Per-IP Rate Limit with Hop Counting
# @RateLimit(
#   key = "#ip",
#   requests = 1000,
#   window = 3600
# )
# X-Forwarded-For: spoofed_ip, client_ip, proxy_ip
# With trusted-hops=1: Uses client_ip (prevents spoofing)

# Example 3: Tiered Limits
# @RateLimits({
#   @RateLimit(name = "burst", requests = 10, window = 1),
#   @RateLimit(name = "hourly", requests = 1000, window = 3600)
# })

# Example 4: RFC 9457 Response
# HTTP/1.1 429 Too Many Requests
# Content-Type: application/problem+json
# Retry-After: 24
# RateLimit-Policy: 100;w=60
#
# {
#   "type": "https://ratelimit.io/probs/too-many-requests",
#   "title": "Too Many Requests",
#   "status": 429,
#   "detail": "Quota exceeded. Please try again in 24 seconds.",
#   "instance": "/api/v1/orders",
#   "retry_after": 24,
#   "limit": 100,
#   "remaining": 0,
#   "reset": 1640995200
# }

# ========================================
# DEPLOYMENT RECOMMENDATIONS
# ========================================

# Small (1-5 nodes): Use in-memory storage
# No proxy configuration needed if direct connections

# Medium (5-50 nodes): Use Redis
# Configure trusted proxies for load balancer

# Large (50+ nodes): Use tiered storage (Redis L1 + Caffeine L2)
# Configure full hop counting for CDN + load balancer
#   trusted-hops: 2
#   trusted-proxies: [CDN IPs, LB IPs, K8s network]

# ========================================
# SECURITY NOTES
# ========================================

# 1. HOP COUNTING SECURITY
#    - ALWAYS configure trusted-proxies in production
#    - NEVER trust all proxies in public-facing services
#    - Verify your infrastructure layout matches trusted-hops

# 2. ADAPTIVE THROTTLING
#    - Use blocking delay (Thread.sleep) for MVC apps
#    - Monitor thread pool utilization during high load
#    - Consider fail-closed strategy for critical APIs

# 3. PROBLEM DETAILS
#    - Set include-extensions: false to hide rate limit details
#    - Use custom type-uri for your organization
#    - Monitor for information disclosure in error messages
